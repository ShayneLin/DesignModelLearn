
使用装饰者模式实现变形金刚（变形金刚从car->robot->airplane）

Transform接口（抽象构建类）
    +具有move()方法

Car类是具体构件（也是装饰器需要装饰的目标对象）实现了Transform接口

Changer类是装饰器的抽象类（装饰器）实现了Transform接口
    —关键是它还持有一个Transform的成员变量，以此来获取具体构件的引用进而为其增加新行为
    -有两个具体的装饰类具体实现类：
          类1：Robot类增加了say()方法
          类2：Airplane类增加了fly()方法
          
调用的流程：
   1.在客户端类中创建car对象根据抽象构件来创建。
   2.先不添加装饰，调用一下move()
   3.通过装饰类新建装饰对象robot和airplane同时将car传入
   4.调用move()和say()或者fly()进行测试
   5.结束
一些个人的想法和疑惑：
       其实装饰器不实现Transform接口也可以实现上述的过程，因为所谓的装饰器，不过是持有了
   构件对象的具体装饰对象。当然不实现自Transform的话我们就需要知道自己定义的方法是否
 与具体构件的方法是否同名（表达同样的意思），也许需要抽象装饰器类实现抽象构件的接口的原因
 就是这个。
 
适用的环境：
  1.在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
  2.需要动态的给一个对象增加功能，这些功能也可以动态的撤销。
  3.不能使用继承的方式来新增功能的地方。
 
 
 优点：
   1.装饰模式和继承关系的目的都是要拓展对象的功能，但是装饰模式可以提供比继承更多的
灵活性。
   2.可以动态的方式来拓展一个对象的功能。
   3.通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。
   4.具体构件类和具体装饰类可以独立变化，符合开闭原则。

缺点：
   1.使用装饰器模式进行系统设计时会产生很多小对象，增加了系统的复杂度。
   2.比继承更加灵活但是意味着更加容易出错且排错难度较高。
   